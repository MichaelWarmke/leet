

implement minHeap -- 
reverse linkedList -- 
reverse binary tree -- 
adjacent list -- 
BFS -- 
DFS inorder, preorder, postorder -- 
binarySearch -- 
trie -- 

---

Big O for all categories on needcode
- Arrays
  iterating through o(n)
- Hashing
  look ups O(1)
  insert O(1)
  deleting O(1)  
- TwoPointers/SlidingWindow
  iterating through O(1)
- Stack insert O(1) remove O(1) search O(n)
- BinarySearch O(logn)
- LinkedList
- Trees
  BST insert O(logn) delete O(logn) search O(logn)
  decision binary tree iteration 2 ^ N 
- Tries
- Heaps
- BackTracking
- Graphs
- Dynamic programming
- Greedy
- Intervals
- Math
    

implement sorting algos nlogn
- mergesort -- 
- quicksort
- heapsort -- 

how to implement hashtable in kotlin only using arrays -- good here well not really
  separate chaining -- 
  linear probing -- 

trees
- DFS inorder, preorder, postorder 
- BFS 
- binary tree
- n ary tree
- trie
- one type of self-balancing tree, red/black, AVL, splay, B tree
  implement one of these trees -- ill do this at the end

graphs 
- know how to represent them in memory, pointers and objects, matrix, adjacency list
  al -- good
  pointers and objects -- 
  grid --
- pro and con of the above
- BFS and DFS in a graph and there complexity
- Dijkstra

Famous NP-Complete problems
traveling salesman
knapsack problem

Math
- discrete math
- combinations formula
- permutation formula
- combinatorics
- n choose k problems