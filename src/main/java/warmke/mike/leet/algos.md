
# Breadth-first search
Search all child elements 

# Sort


sort on collections O(nlogn) using quicksort/merge/heap

### Heapsort

divides array into two sections sorted and unsorted
it finds the highest value and puts it into the sorted section

all the unsorted values are in a heap, and it uses this to 

### TimSort

a mixture of MergeSort and Binary Insertion Sort
it's adaptive in that it handles input data differently based on some factors 

Small input sizes below 64 elements uses binary linear search and binary insertion sort

this is a stable sort in that elements that are equal are not moved around by this search

# Insert

    hashmap O(1) worst O(n)
    array O(n)
    stack/queue/linkedList/doubleLinkedList O(1)

    binary search tree O(log n) worst O(n)
    b tree O(log n)

# Delete

    hashmap O(1) worst O(n)
    array O(n)
    stack/queue/linkedList/doubleLinkedList O(1)

    binary search tree O(log n) worst O(n)
    b tree O(log n)

# Look up Access

    hashmap O(1) worst O(n)
    array O(1)
    stack/queue/linkedList/doubleLinkedList O(n)

    binary search tree O(log n) worst O(n)
    b tree O(log n)

# Search

    array O(n)
    stack/queue/linkedList/doubleLinkedList O(n)

    binary search tree O(log n) worst O(n)
    b tree O(log n)

